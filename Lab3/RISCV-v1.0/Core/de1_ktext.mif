DEPTH = 2048;
WIDTH = 32;
ADDRESS_RADIX = HEX;
DATA_RADIX = HEX;
CONTENT
BEGIN
00000000 : 23bdfff8;   % 161: exceptionHandling:  addi    $sp, $sp, -8 # aloca espaco  %
00000001 : afa10000;   % 162:     sw      $at, 0($sp)			# salva $at %
00000002 : afbf0004;   % 163:     sw      $ra, 4($sp)			# salva $ra %
00000003 : 201a0020;   % 165:     addi    $k0, $zero, 32              # default syscall exception=8*4 %
00000004 : 401a6800;   % 166:     mfc0    $k0, $13                    # nao esta implementada no pipeline, então usa o default 32 %
00000005 : 00000000;   % 167:     nop                                 # nao retirar! %
00000006 : 335a007c;   % 168:     andi    $k0, $k0, 0x007C		# mascarar 0000000001111100 %
00000007 : 001ad082;   % 169:     srl     $k0, $k0, 2			# retira os 2 bits iniciais %
00000008 : 201b0008;   % 171:     addi    $k1, $zero, 8               # excecao de syscall %
00000009 : 137a0058;   % 172:     beq     $k1, $k0, syscallException %
0000000a : 201b0000;   % 174:     addi    $k1, $zero, 0               # interrupcoes %
0000000b : 137a0010;   % 175:     beq     $k1, $k0, interruptException %
0000000c : 201b000a;   % 177:     addi    $k1, $zero, 10              # excecao instrucao reservada ou invalida %
0000000d : 137a0048;   % 178:     beq     $k1, $k0, instructionException %
0000000e : 201b000c;   % 180:     addi    $k1, $zero, 12              # excecao overflow na ULA %
0000000f : 137a000a;   % 181:     beq     $k1, $k0, ALUOverflowException %
00000010 : 201b000f;   % 183:     addi    $k1, $zero, 15              # excecao de ponto flutuante %
00000011 : 137a0009;   % 184:     beq     $k1, $k0, FPALUException %
00000012 : 8fbf0004;   % 186: endException: 	lw    	$ra, 4($sp)		# recupera $ra %
00000013 : 8fa10000;   % 187:     		lw      $at, 0($sp)		# recupera $at %
00000014 : 23bd0008;   % 188:     		addi    $sp, $sp, 8		# libera espaco %
00000015 : 401a7000;   % 190:     		mfc0    $k0, $14                # le EPC     //NOTE: nao esta implementada no pipe %
00000016 : 235a0004;   % 191:     		addi    $k0, $k0, 4		# EPC+4 %
00000017 : 409a7000;   % 192:     		mtc0    $k0, $14                # move para EPC     // nao esta implementada no pipeline %
00000018 : 42000018;   % 193:     		eret                            # Retorna ao EPC - fim exception handler %
00000019 : 00000000;   % 194:     		nop %
0000001a : 08000012;   % 196: ALUOverflowException:   j endException  # escolhi nao fazer nada, ja que ate hoje nunca vi um SO tratar esse tipo de excecao...  by Matheus Pimenta %
0000001b : 08000012;   % 198: FPALUException:         j endException  # escolhi nao fazer nada, ja que ate hoje nunca vi um SO tratar esse tipo de excecao... by Matheus Pimenta %
0000001c : 401a6800;   % 200: interruptException:     mfc0    $k0, $13  		# le o codigo da interrupcao %
0000001d : 335aff00;   % 201:     			andi    $k0, $k0, 0xFF00	# mascara 1111111100000000 %
0000001e : 001ad202;   % 202:     			srl     $k0, $k0, 8		# desloca 8 bits %
0000001f : 335b0001;   % 204:     		andi    $k1, $k0, 0x0001		# interrupcao 1 : Teclado - implementada mas desabilitada %
00000020 : 17600014;   % 205:     		bne     $k1, $zero, keyboardInterrupt %
00000021 : 335b0002;   % 207:     		andi    $k1, $k0, 0x0002		# interrupcao 2 : Audio	- nao implementada %
00000022 : 17600010;   % 208:     		bne     $k1, $zero, audioInterrupt %
00000023 : 335b0004;   % 210:     		andi    $k1, $k0, 0x0004		# interruopcao 4: Mouse	- nao implementada %
00000024 : 1760000f;   % 211:     		bne     $k1, $zero, mouseInterrupt %
00000025 : 335b0008;   % 213:     		andi    $k1, $k0, 0x0008            	# interrupcao 8: Watchdog - nao implementada %
00000026 : 1760000b;   % 214:     		bne     $k1, $zero, counterInterrupt %
00000027 : 335b0010;   % 216:     		andi $k1, $k0, 0x0010              	# interrupcao 16: do Keyboard and Display Interrupt Tool %
00000028 : 17600001;   % 217:     		bne $k1, $zero, KDMMIOInterrupt %
00000029 : 08000012;   % 219:     		j       endException	# se nao for nenhuma dessas finaliza o tratamento de excecao %
0000002a : 3c01ff20;   % 221: KDMMIOInterrupt:  la $k1, 0xFF200000		# carrega endereco de controle do buffer teclado %
0000002b : 343b0000;   % 221:  %
0000002c : 8f7a0004;   % 222: 		lw $k0,4($k1)	            	# codigo ascii da tecla lida %
0000002d : af7a000c;   % 224: 		sw $k0,12($k1)	            	# imprime no Display <<<<<<<<<<<<<< Colocar aqui o que deve ser feito com a tecla lida		 %
0000002e : 401a7000;   % 226: 		mfc0 $k0,$14  	            	# O Mars ja soma 4! Le o EPC %
0000002f : 235afffc;   % 227: 		addi $k0,$k0,-4	            	# Entao precisa tirar 4 do EPC pois vai somar 4 novamente no endException %
00000030 : 409a7000;   % 228: 		mtc0 $k0,$14 			# Coloca endereco no EPC %
00000031 : 08000012;   % 229: 		j endException %
00000032 : 08000012;   % 231: counterInterrupt:   j endException      # nenhum tratamento para a interrupcao de contagem eh necessario ate agora %
00000033 : 08000012;   % 233: audioInterrupt:     j endException      # TODO: Implementar interrupcao de audio. %
00000034 : 08000012;   % 236: mouseInterrupt:	    j endException    %
00000035 : 23bdfff8;   % 326: keyboardInterrupt: 	addi    $sp, $sp, -8  		# aloca espaco %
00000036 : afa40000;   % 327:     			sw      $a0, 0($sp)        	# salva $a0 %
00000037 : afa20004;   % 328:     			sw      $v0, 4($sp)		# salva $v0 %
00000038 : 3c019000;   % 331:     	la      $a0, eventQueueEndPtr		# ponteiro da fila de eventos %
00000039 : 342406a0;   % 331:  %
0000003a : 8c840000;   % 332:     	lw      $a0, 0($a0)			# le o endereco da fila de eventos %
0000003b : 0c00004c;   % 333:     	jal     eventQueueIncrementPointer	# %
0000003c : 3c019000;   % 334:     	la      $k0, eventQueueBeginPtr		# %
0000003d : 343a069c;   % 334:  %
0000003e : 8f5a0000;   % 335:     	lw      $k0, 0($k0)			# %
0000003f : 13420008;   % 336:     	beq     $k0, $v0, keyboardInterruptEnd	# %
00000040 : 3c01ff20;   % 339:     	la      $k0, 0xFF200100			# carrega o endereco do Buffer0Teclado %
00000041 : 343a0100;   % 339:  %
00000042 : 8f5a0000;   % 340:     	lw      $k0, 0($k0)				# carrega o Buffer0 %
00000043 : 001ac821;   % 341:     	move    $t9, $k0				# %
00000044 : ac9a0000;   % 344:     	sw      $k0, 0($a0) %
00000045 : 3c019000;   % 345:     	la      $k0, eventQueueEndPtr %
00000046 : 343a06a0;   % 345:  %
00000047 : af420000;   % 346: 	sw      $v0, 0($k0) %
00000048 : 8fa40000;   % 348: keyboardInterruptEnd:   lw      $a0, 0($sp)	# recupera $a0 %
00000049 : 8fa20004;   % 349:     			lw      $v0, 4($sp)	# rercupera $v0 %
0000004a : 23bd0008;   % 350:     			addi    $sp, $sp, 8 	# libera espaco %
0000004b : 08000012;   % 351:     			j       endException	# retorna %
0000004c : 20820004;   % 354: eventQueueIncrementPointer:     addi    $v0, $a0, 4 %
0000004d : 3c019000;   % 355:     				la      $t0, eventQueueEndAddr %
0000004e : 34280698;   % 355:  %
0000004f : 8d080000;   % 356:     				lw      $t0, 0($t0) %
00000050 : 11020001;   % 357:     				beq     $t0, $v0, eventQueueIncrementPointerIf %
00000051 : 03e00008;   % 358:     				jr      $ra %
00000052 : 3c019000;   % 360: eventQueueIncrementPointerIf:   la      $v0, eventQueueBeginAddr %
00000053 : 34220694;   % 360:  %
00000054 : 8c420000;   % 361:     				lw      $v0, 0($v0) %
00000055 : 03e00008;   % 362:     				jr      $ra %
00000056 : 3c019000;   % 380: instructionException: 	la 	$a0, instructionMessage		# endereco da mensagem %
00000057 : 34240424;   % 380:  %
00000058 : 24050000;   % 381: 				li 	$a1, 0				# posicao X %
00000059 : 24060000;   % 382:   				li 	$a2, 0				# posicao Y %
0000005a : 2407000f;   % 383:   				li 	$a3, 0x0F			# cor vermelho sobre preto %
0000005b : 0c000198;   % 384:   				jal 	printString			# chama o printString %
0000005c : 40047000;   % 386:   				mfc0 	$a0, $14			# recupera o EPC: Endereco onde ocorreu o erro %
0000005d : 240500e8;   % 387:   				li 	$a1, 232			# posicao X %
0000005e : 24060000;   % 388:   				li 	$a2,0				# posicao Y %
0000005f : 2407000f;   % 389:   				li 	$a3,0x0F			# cor vermelho sobre preto %
00000060 : 0c00017a;   % 390:   				jal 	printHex			# chama printHex %
00000061 : 08000132;   % 392:   				j goToExit %
00000062 : 23bdfef8;   % 396: syscallException:     addi    $sp, $sp, -264              # Salva todos os registradores na pilha %
00000063 : afa10000;   % 397:     sw      $1,     0($sp) %
00000064 : afa20004;   % 398:     sw      $2,     4($sp) %
00000065 : afa30008;   % 399:     sw      $3,     8($sp) %
00000066 : afa4000c;   % 400:     sw      $4,    12($sp) %
00000067 : afa50010;   % 401:     sw      $5,    16($sp) %
00000068 : afa60014;   % 402:     sw      $6,    20($sp) %
00000069 : afa70018;   % 403:     sw      $7,    24($sp) %
0000006a : afa8001c;   % 404:     sw      $8,    28($sp) %
0000006b : afa90020;   % 405:     sw      $9,    32($sp) %
0000006c : afaa0024;   % 406:     sw      $10,   36($sp) %
0000006d : afab0028;   % 407:     sw      $11,   40($sp) %
0000006e : afac002c;   % 408:     sw      $12,   44($sp) %
0000006f : afad0030;   % 409:     sw      $13,   48($sp) %
00000070 : afae0034;   % 410:     sw      $14,   52($sp) %
00000071 : afaf0038;   % 411:     sw      $15,   56($sp) %
00000072 : afb0003c;   % 412:     sw      $16,   60($sp) %
00000073 : afb10040;   % 413:     sw      $17,   64($sp) %
00000074 : afb20044;   % 414:     sw      $18,   68($sp) %
00000075 : afb30048;   % 415:     sw      $19,   72($sp) %
00000076 : afb4004c;   % 416:     sw      $20,   76($sp) %
00000077 : afb50050;   % 417:     sw      $21,   80($sp) %
00000078 : afb60054;   % 418:     sw      $22,   84($sp) %
00000079 : afb70058;   % 419:     sw      $23,   88($sp) %
0000007a : afb8005c;   % 420:     sw      $24,   92($sp) %
0000007b : afb90060;   % 421:     sw      $25,   96($sp) %
0000007c : afba0064;   % 422:     sw      $26,  100($sp) %
0000007d : afbb0068;   % 423:     sw      $27,  104($sp) %
0000007e : afbc006c;   % 424:     sw      $28,  108($sp) %
0000007f : afbd0070;   % 425:     sw      $29,  112($sp) %
00000080 : afbe0074;   % 426:     sw      $30,  116($sp) %
00000081 : afbf0078;   % 427:     sw      $31,  120($sp) %
00000082 : e7a0007c;   % 428:     swc1    $f0,  124($sp) %
00000083 : e7a10080;   % 429:     swc1    $f1,  128($sp) %
00000084 : e7a20084;   % 430:     swc1    $f2,  132($sp) %
00000085 : e7a30088;   % 431:     swc1    $f3,  136($sp) %
00000086 : e7a4008c;   % 432:     swc1    $f4,  140($sp) %
00000087 : e7a50090;   % 433:     swc1    $f5,  144($sp) %
00000088 : e7a60094;   % 434:     swc1    $f6,  148($sp) %
00000089 : e7a70098;   % 435:     swc1    $f7,  152($sp) %
0000008a : e7a8009c;   % 436:     swc1    $f8,  156($sp) %
0000008b : e7a900a0;   % 437:     swc1    $f9,  160($sp) %
0000008c : e7aa00a4;   % 438:     swc1    $f10, 164($sp) %
0000008d : e7ab00a8;   % 439:     swc1    $f11, 168($sp) %
0000008e : e7ac00ac;   % 440:     swc1    $f12, 172($sp) %
0000008f : e7ad00b0;   % 441:     swc1    $f13, 176($sp) %
00000090 : e7ae00b4;   % 442:     swc1    $f14, 180($sp) %
00000091 : e7af00b8;   % 443:     swc1    $f15, 184($sp) %
00000092 : e7b000bc;   % 444:     swc1    $f16, 188($sp) %
00000093 : e7b100c0;   % 445:     swc1    $f17, 192($sp) %
00000094 : e7b200c4;   % 446:     swc1    $f18, 196($sp) %
00000095 : e7b300c8;   % 447:     swc1    $f19, 200($sp) %
00000096 : e7b400cc;   % 448:     swc1    $f20, 204($sp) %
00000097 : e7b500d0;   % 449:     swc1    $f21, 208($sp) %
00000098 : e7b600d4;   % 450:     swc1    $f22, 212($sp) %
00000099 : e7b700d8;   % 451:     swc1    $f23, 216($sp) %
0000009a : e7b800dc;   % 452:     swc1    $f24, 220($sp) %
0000009b : e7b900e0;   % 453:     swc1    $f25, 224($sp) %
0000009c : e7ba00e4;   % 454:     swc1    $f26, 228($sp) %
0000009d : e7bb00e8;   % 455:     swc1    $f27, 232($sp) %
0000009e : e7bc00ec;   % 456:     swc1    $f28, 236($sp) %
0000009f : e7bd00f0;   % 457:     swc1    $f29, 240($sp) %
000000a0 : e7be00f4;   % 458:     swc1    $f30, 244($sp) %
000000a1 : e7bf00f8;   % 459:     swc1    $f31, 248($sp) %
000000a2 : 0000d010;   % 461:     mfhi    $k0 %
000000a3 : afba00fc;   % 462:     sw      $k0, 252($sp) %
000000a4 : 0000d012;   % 463:     mflo    $k0 %
000000a5 : afba0100;   % 464:     sw      $k0, 256($sp) %
000000a6 : 00004020;   % 467:     add     $t0, $zero, $zero %
000000a7 : 00004820;   % 468:     add     $t1, $zero, $zero %
000000a8 : 00005020;   % 469:     add     $t2, $zero, $zero %
000000a9 : 00005820;   % 470:     add     $t3, $zero, $zero %
000000aa : 00006020;   % 471:     add     $t4, $zero, $zero %
000000ab : 00006820;   % 472:     add     $t5, $zero, $zero %
000000ac : 00007020;   % 473:     add     $t6, $zero, $zero %
000000ad : 00007820;   % 474:     add     $t7, $zero, $zero %
000000ae : 0000c020;   % 475:     add     $t8, $zero, $zero %
000000af : 0000c820;   % 476:     add     $t9, $zero, $zero %
000000b0 : 2008000a;   % 479:     addi    $t0, $zero, 10 %
000000b1 : 11020080;   % 480:     beq     $t0, $v0, goToExit          # syscall exit %
000000b2 : 2008006e;   % 481:     addi    $t0, $zero, 110 %
000000b3 : 1102007e;   % 482:     beq     $t0, $v0, goToExit          # syscall exit %
000000b4 : 20080001;   % 484:     addi    $t0, $zero, 1               # sycall 1 = print int %
000000b5 : 11020082;   % 485:     beq     $t0, $v0, goToPrintInt %
000000b6 : 20080065;   % 486:     addi    $t0, $zero, 101             # sycall 1 = print int %
000000b7 : 11020080;   % 487:     beq     $t0, $v0, goToPrintInt %
000000b8 : 20080002;   % 489:     addi    $t0, $zero, 2               # syscall 2 = print float %
000000b9 : 11020084;   % 490:     beq     $t0, $v0, goToPrintFloat %
000000ba : 20080066;   % 491:     addi    $t0, $zero, 102             # syscall 2 = print float %
000000bb : 11020082;   % 492:     beq     $t0, $v0, goToPrintFloat %
000000bc : 20080004;   % 494:     addi    $t0, $zero, 4               # syscall 4 = print string %
000000bd : 1102007c;   % 495:     beq     $t0, $v0, goToPrintString %
000000be : 20080068;   % 496:     addi    $t0, $zero, 104             # syscall 4 = print string %
000000bf : 1102007a;   % 497:     beq     $t0, $v0, goToPrintString %
000000c0 : 20080005;   % 499:     addi    $t0, $zero, 5               # syscall 5 = read int %
000000c1 : 11020080;   % 500:     beq     $t0, $v0, goToReadInt %
000000c2 : 20080069;   % 501:     addi    $t0, $zero, 105             # syscall 5 = read int %
000000c3 : 1102007e;   % 502:     beq     $t0, $v0, goToReadInt %
000000c4 : 20080006;   % 504:     addi    $t0, $zero, 6               # syscall 6 = read float %
000000c5 : 11020080;   % 505:     beq     $t0, $v0, goToReadFloat %
000000c6 : 2008006a;   % 506:     addi    $t0, $zero, 106             # syscall 6 = read float %
000000c7 : 1102007e;   % 507:     beq     $t0, $v0, goToReadFloat %
000000c8 : 20080008;   % 509:     addi    $t0, $zero, 8               # syscall 8 = read string %
000000c9 : 1102007a;   % 510:     beq     $t0, $v0, goToReadString %
000000ca : 2008006c;   % 511:     addi    $t0, $zero, 108             # syscall 8 = read string %
000000cb : 11020078;   % 512:     beq     $t0, $v0, goToReadString %
000000cc : 2008000b;   % 514:     addi    $t0, $zero, 11              # syscall 11 = print char %
000000cd : 1102006e;   % 515:     beq     $t0, $v0, goToPrintChar %
000000ce : 2008006f;   % 516:     addi    $t0, $zero, 111             # syscall 11 = print char %
000000cf : 1102006c;   % 517:     beq     $t0, $v0, goToPrintChar %
000000d0 : 2008000c;   % 519:     addi    $t0, $zero, 12              # syscall 12 = read char %
000000d1 : 1102006e;   % 520:     beq     $t0, $v0, goToReadChar %
000000d2 : 20080070;   % 521:     addi    $t0, $zero, 112             # syscall 12 = read char %
000000d3 : 1102006c;   % 522:     beq     $t0, $v0, goToReadChar %
000000d4 : 2008001e;   % 524:     addi    $t0, $zero, 30              # syscall 30 = time %
000000d5 : 1102007a;   % 525:     beq     $t0, $v0, goToTime %
000000d6 : 20080082;   % 526:     addi    $t0, $zero, 130             # syscall 30 = time %
000000d7 : 11020078;   % 527:     beq     $t0, $v0, goToTime %
000000d8 : 20080020;   % 529:     addi    $t0, $zero, 32              # syscall 32 = sleep %
000000d9 : 11020078;   % 530:     beq     $t0, $v0, goToSleep %
000000da : 20080084;   % 531:     addi    $t0, $zero, 132             # syscall 32 = sleep %
000000db : 11020076;   % 532:     beq     $t0, $v0, goToSleep %
000000dc : 20080029;   % 534:     addi    $t0, $zero, 41              # syscall 41 = random %
000000dd : 11020076;   % 535:     beq     $t0, $v0, goToRandom %
000000de : 2008008d;   % 536:     addi    $t0, $zero, 141             # syscall 41 = random %
000000df : 11020074;   % 537:     beq     $t0, $v0, goToRandom %
000000e0 : 20080022;   % 539:     addi    $t0, $zero, 34       	# syscall 34 = print hex %
000000e1 : 11020066;   % 540:     beq     $t0, $v0, goToPrintHex %
000000e2 : 20080086;   % 541:     addi    $t0, $zero, 134		# syscall 41 = print hex %
000000e3 : 11020064;   % 542:     beq     $t0, $v0, goToPrintHex %
000000e4 : 2008001f;   % 544:     addi    $t0, $zero, 31              # syscall 31 = MIDI out %
000000e5 : 11020064;   % 545:     beq     $t0, $v0, goToMidiOut       # Generate tone and return immediately %
000000e6 : 20080083;   % 546:     addi    $t0, $zero, 131             # syscall 31 = MIDI out %
000000e7 : 11020062;   % 547:     beq     $t0, $v0, goToMidiOut %
000000e8 : 20080021;   % 549:     addi    $t0, $zero, 33              # syscall 33 = MIDI out synchronous %
000000e9 : 11020062;   % 550:     beq     $t0, $v0, goToMidiOutSync   # Generate tone and return upon tone completion %
000000ea : 20080085;   % 551:     addi    $t0, $zero, 133             # syscall 33 = MIDI out synchronous %
000000eb : 11020060;   % 552:     beq     $t0, $v0, goToMidiOutSync %
000000ec : 20080030;   % 559:     addi    $t0, $zero, 48              # syscall 48 = CLS %
000000ed : 11020068;   % 560:     beq     $t0, $v0, goToCLS %
000000ee : 20080094;   % 561:     addi    $t0, $zero, 148              # syscall 48 = CLS %
000000ef : 11020066;   % 562:     beq     $t0, $v0, goToCLS %
000000f0 : 20080096;   % 564:     addi    $t0, $zero, 150             # syscall 150 = pop event %
000000f1 : 1102005c;   % 565:     beq     $t0, $v0, goToPopEvent %
000000f2 : 8fa10000;   % 568: endSyscall:	lw	$1, 0($sp)  # recupera QUASE todos os registradores na pilha %
000000f3 : 8fa60014;   % 573:     lw	    $6,  20($sp)	 %
000000f4 : 8fa70018;   % 574:     lw      $7,  24($sp) %
000000f5 : 8fa8001c;   % 575:     lw 	    $8,  28($sp) %
000000f6 : 8fa90020;   % 576:     lw      $9,    32($sp) %
000000f7 : 8faa0024;   % 577:     lw      $10,   36($sp) %
000000f8 : 8fab0028;   % 578:     lw      $11,   40($sp) %
000000f9 : 8fac002c;   % 579:     lw      $12,   44($sp) %
000000fa : 8fad0030;   % 580:     lw      $13,   48($sp) %
000000fb : 8fae0034;   % 581:     lw      $14,   52($sp) %
000000fc : 8faf0038;   % 582:     lw      $15,   56($sp) %
000000fd : 8fb0003c;   % 583:     lw      $16,   60($sp) %
000000fe : 8fb10040;   % 584:     lw      $17,   64($sp) %
000000ff : 8fb20044;   % 585:     lw      $18,   68($sp) %
00000100 : 8fb30048;   % 586:     lw      $19,   72($sp) %
00000101 : 8fb4004c;   % 587:     lw      $20,   76($sp) %
00000102 : 8fb50050;   % 588:     lw      $21,   80($sp) %
00000103 : 8fb60054;   % 589:     lw      $22,   84($sp) %
00000104 : 8fb70058;   % 590:     lw      $23,   88($sp) %
00000105 : 8fb8005c;   % 591:     lw      $24,   92($sp) %
00000106 : 8fb90060;   % 592:     lw      $25,   96($sp) %
00000107 : 8fba0064;   % 593:     lw      $26,  100($sp) %
00000108 : 8fbb0068;   % 594:     lw      $27,  104($sp) %
00000109 : 8fbc006c;   % 595:     lw      $28,  108($sp) %
0000010a : 8fbd0070;   % 596:     lw      $29,  112($sp) %
0000010b : 8fbe0074;   % 597:     lw      $30,  116($sp) %
0000010c : 8fbf0078;   % 598:     lw      $31,  120($sp) %
0000010d : c7a10080;   % 600:     lwc1    $f1,  128($sp) %
0000010e : c7a20084;   % 601:     lwc1    $f2,  132($sp) %
0000010f : c7a30088;   % 602:     lwc1    $f3,  136($sp) %
00000110 : c7a4008c;   % 603:     lwc1    $f4,  140($sp) %
00000111 : c7a50090;   % 604:     lwc1    $f5,  144($sp) %
00000112 : c7a60094;   % 605:     lwc1    $f6,  148($sp) %
00000113 : c7a70098;   % 606:     lwc1    $f7,  152($sp) %
00000114 : c7a8009c;   % 607:     lwc1    $f8,  156($sp) %
00000115 : c7a900a0;   % 608:     lwc1    $f9,  160($sp) %
00000116 : c7aa00a4;   % 609:     lwc1    $f10, 164($sp) %
00000117 : c7ab00a8;   % 610:     lwc1    $f11, 168($sp) %
00000118 : c7ac00ac;   % 611:     lwc1    $f12, 172($sp) %
00000119 : c7ad00b0;   % 612:     lwc1    $f13, 176($sp) %
0000011a : c7ae00b4;   % 613:     lwc1    $f14, 180($sp) %
0000011b : c7af00b8;   % 614:     lwc1    $f15, 184($sp) %
0000011c : c7b000bc;   % 615:     lwc1    $f16, 188($sp) %
0000011d : c7b100c0;   % 616:     lwc1    $f17, 192($sp) %
0000011e : c7b200c4;   % 617:     lwc1    $f18, 196($sp) %
0000011f : c7b300c8;   % 618:     lwc1    $f19, 200($sp) %
00000120 : c7b400cc;   % 619:     lwc1    $f20, 204($sp) %
00000121 : c7b500d0;   % 620:     lwc1    $f21, 208($sp) %
00000122 : c7b600d4;   % 621:     lwc1    $f22, 212($sp) %
00000123 : c7b700d8;   % 622:     lwc1    $f23, 216($sp) %
00000124 : c7b800dc;   % 623:     lwc1    $f24, 220($sp) %
00000125 : c7b900e0;   % 624:     lwc1    $f25, 224($sp) %
00000126 : c7ba00e4;   % 625:     lwc1    $f26, 228($sp) %
00000127 : c7bb00e8;   % 626:     lwc1    $f27, 232($sp) %
00000128 : c7bc00ec;   % 627:     lwc1    $f28, 236($sp) %
00000129 : c7bd00f0;   % 628:     lwc1    $f29, 240($sp) %
0000012a : c7be00f4;   % 629:     lwc1    $f30, 244($sp) %
0000012b : c7bf00f8;   % 630:     lwc1    $f31, 248($sp) %
0000012c : 8fba00fc;   % 632:     lw      $k0,  252($sp) %
0000012d : 03400011;   % 633:     mthi    $k0 %
0000012e : 8fba0100;   % 634:     lw      $k0,  256($sp) %
0000012f : 03400013;   % 635:     mtlo    $k0			# $k0 fica com lixo mesmo %
00000130 : 23bd0108;   % 637:     addi    $sp, $sp, 264 %
00000131 : 08000012;   % 638:     j endException %
00000132 : 3c011000;   % 641: <57> bne $gp,0x10008000,goToExitDE2 %
00000133 : 34218000;   % 641:  %
00000134 : 143c0002;   % 641:  %
00000135 : 2402000a;   % 642:   		li 	$v0, 10		# chama o syscal normal do Mars %
00000136 : 0000000c;   % 643:   		syscall			# exit syscall %
00000137 : 08000137;   % 645: goToExitDE2:	j       goToExitDE2     ########### syscall 10 ou 110 %
00000138 : 0c000158;   % 647: goToPrintInt:	jal     printInt               	# chama printInt %
00000139 : 080000f2;   % 648: 		j       endSyscall %
0000013a : 0c000198;   % 650: goToPrintString: jal     printString           	# chama printString %
0000013b : 080000f2;   % 651:     		j       endSyscall %
0000013c : 0c0001aa;   % 653: goToPrintChar:	jal     printChar		# chama printChar %
0000013d : 080000f2;   % 654:     		j       endSyscall %
0000013e : 0c00029d;   % 656: goToPrintFloat:	jal     printFloat		# chama printFloat %
0000013f : 080000f2;   % 657:     		j       endSyscall %
00000140 : 0c0001e4;   % 659: goToReadChar:	jal     readChar              	# chama readChar %
00000141 : 080000f2;   % 660:     		j       endSyscall %
00000142 : 0c000227;   % 662: goToReadInt:   	jal     readInt                 # chama readInt %
00000143 : 080000f2;   % 663:     		j       endSyscall %
00000144 : 0c000213;   % 665: goToReadString:	jal     readString              # chama readString %
00000145 : 080000f2;   % 666:     		j       endSyscall %
00000146 : 0c000316;   % 668: goToReadFloat:	jal     readFloat               # chama readFloat %
00000147 : 080000f2;   % 669: 		j       endSyscall %
00000148 : 0c00017a;   % 671: goToPrintHex:	jal     printHex                # chama printHex %
00000149 : 080000f2;   % 672: 		j       endSyscall %
0000014a : 0c00024a;   % 674: goToMidiOut:	jal     midiOut                 # chama MIDIout %
0000014b : 080000f2;   % 675:     		j       endSyscall %
0000014c : 0c000265;   % 677: goToMidiOutSync:     	jal     midiOutSync   	# chama MIDIoutSync %
0000014d : 080000f2;   % 678:     			j       endSyscall %
0000014e : 0c000287;   % 683: goToPopEvent:	jal     popEvent                # chama popEvent %
0000014f : 080000f2;   % 684:     		j       endSyscall %
00000150 : 0c0003ba;   % 686: goToTime:	jal     time                    # chama time %
00000151 : 080000f2;   % 687:     		j       endSyscall %
00000152 : 0c0003c5;   % 689: goToSleep:	jal     sleep                  	# chama sleep %
00000153 : 080000f2;   % 690: 		j       endSyscall %
00000154 : 0c0003d3;   % 692: goToRandom:	jal     random                 	# chama random %
00000155 : 080000f2;   % 693:     		j       endSyscall %
00000156 : 0c0003dd;   % 695: goToCLS:	jal     clsCLS                 	# chama CLS %
00000157 : 080000f2;   % 696:     		j       endSyscall %
00000158 : 23bdfffc;   % 708: printInt:	addi 	$sp, $sp, -4			# Aloca espaco %
00000159 : afbf0000;   % 709: 		sw 	$ra, 0($sp)			# salva $ra %
0000015a : 3c019000;   % 710: 		la 	$t0, TempBuffer			# carrega o Endereco do Buffer da String %
0000015b : 3428044c;   % 710:  %
0000015c : 0080082a;   % 712: 		bge 	$a0, $zero, ehposprintInt	# Se eh positvo %
0000015d : 10200004;   % 712:  %
0000015e : 2409002d;   % 713: 		li 	$t1, '-'			# carrega o sinal - %
0000015f : a1090000;   % 714: 		sb 	$t1, 0($t0)			# coloca no buffer %
00000160 : 21080001;   % 715: 		addi 	$t0, $t0, 1			# incrementa endereco do buffer %
00000161 : 00042022;   % 716: 		sub 	$a0, $zero, $a0			# torna o numero positivo %
00000162 : 240a000a;   % 718: ehposprintInt:  li 	$t2, 10				# carrega numero 10 %
00000163 : 24090000;   % 719: 		li 	$t1, 0				# carrega numero de digitos com 0 %
00000164 : 008a001a;   % 721: loop1printInt:	div 	$a0, $t2			# divide por 10 %
00000165 : 00005810;   % 722: 		mfhi 	$t3				# resto %
00000166 : 00006012;   % 723: 		mflo 	$t4				# quociente %
00000167 : 23bdfffc;   % 724: 		addi 	$sp, $sp, -4			# aloca espaco na pilha %
00000168 : afab0000;   % 725: 		sw 	$t3, 0($sp)			# coloca resto na pilha %
00000169 : 000c2021;   % 726: 		move 	$a0, $t4			# atualiza o numero com o quociente %
0000016a : 21290001;   % 727: 		addi 	$t1, $t1, 1			# incrementa o contador de digitos %
0000016b : 1480fff8;   % 728: 		bne 	$a0, $zero, loop1printInt	# verifica se o numero eh zero %
0000016c : 8faa0000;   % 730: loop2printInt:	lw 	$t2, 0($sp)			# le digito da pilha %
0000016d : 23bd0004;   % 731: 		addi 	$sp, $sp, 4			# libera espaco %
0000016e : 214a0030;   % 732: 		addi 	$t2, $t2, 48			# converte o digito para ascii %
0000016f : a10a0000;   % 733: 		sb 	$t2, 0($t0)			# coloca caractere no buffer %
00000170 : 21080001;   % 734: 		addi 	$t0, $t0, 1			# incrementa endereco do buffer %
00000171 : 2129ffff;   % 735: 		addi 	$t1, $t1, -1			# decrementa contador de digitos %
00000172 : 1520fff9;   % 736: 		bne 	$t1, $zero, loop2printInt	# eh o ultimo? %
00000173 : a1000000;   % 737: 		sb 	$zero, 0($t0)			# insere \NULL na string %
00000174 : 3c019000;   % 739: 		la 	$a0, TempBuffer			# Endereco do buffer da srting %
00000175 : 3424044c;   % 739:  %
00000176 : 0c000198;   % 740: 		jal 	printString			# chama o print string %
00000177 : 8fbf0000;   % 742: 		lw 	$ra, 0($sp)			# recupera $a %
00000178 : 23bd0004;   % 743: 		addi 	$sp, $sp, 4			# libera espaco %
00000179 : 03e00008;   % 744: fimprintInt:	jr 	$ra				# retorna %
0000017a : 23bdfffc;   % 756: printHex:	addi    $sp, $sp, -4    		# aloca espaco %
0000017b : afbf0000;   % 757:     		sw      $ra, 0($sp)			# salva $ra %
0000017c : 00044021;   % 758: 		move 	$t0, $a0			# Inteiro de 32 bits a ser impresso em Hexa %
0000017d : 3c019000;   % 759: 		la 	$t1, TabelaHexASCII		# endereco da tabela HEX->ASCII %
0000017e : 34290645;   % 759:  %
0000017f : 3c019000;   % 760: 		la 	$t2, TempBuffer			# onde a string sera montada %
00000180 : 342a044c;   % 760:  %
00000181 : 240b0030;   % 762: 		li 	$t3,'0'			# Caractere '0' %
00000182 : a14b0000;   % 763: 		sb 	$t3,0($t2)		# Escreve '0' no Buffer da String %
00000183 : 240b0078;   % 764: 		li 	$t3,'x'			# Caractere 'x' %
00000184 : a14b0001;   % 765: 		sb 	$t3,1($t2)		# Escreve 'x' no Buffer da String %
00000185 : 214a0002;   % 766: 		addi 	$t2,$t2,2		# novo endereco inicial da string %
00000186 : 240b001c;   % 768: 		li 	$t3, 28			# contador de nibble   inicio = 28 %
00000187 : 0160082a;   % 769: loopprintHex:	blt 	$t3, $zero, fimloopprintHex	# terminou? $t3<0? %
00000188 : 14200008;   % 769:  %
00000189 : 01686006;   % 770: 		srlv 	$t4, $t0, $t3		# desloca o nibble para direita %
0000018a : 318c000f;   % 771: 		andi 	$t4, $t4, 0x000F	# mascara o nibble	 %
0000018b : 012c6020;   % 772: 		add 	$t4, $t1, $t4		# endereco do ascii do nibble %
0000018c : 818c0000;   % 773: 		lb 	$t4, 0($t4)		# le ascii do nibble %
0000018d : a14c0000;   % 774: 		sb 	$t4, 0($t2)		# armazena o ascii do nibble no buffer da string %
0000018e : 214a0001;   % 775: 		addi 	$t2, $t2, 1		# incrementa o endereco do buffer %
0000018f : 216bfffc;   % 776: 		addi 	$t3, $t3, -4		# decrementa o numero do nibble %
00000190 : 08000187;   % 777: 		j 	loopprintHex %
00000191 : a1400000;   % 779: fimloopprintHex: sb 	$zero,0($t2)		# grava \null na string %
00000192 : 3c019000;   % 780: 		la 	$a0, TempBuffer		# Argumento do print String %
00000193 : 3424044c;   % 780:  %
00000194 : 0c000198;   % 781:     		jal	printString		# Chama o print string %
00000195 : 8fbf0000;   % 783: 		lw 	$ra, 0($sp)		# recupera $ra %
00000196 : 23bd0004;   % 784: 		addi 	$sp, $sp, 4		# libera espaco %
00000197 : 03e00008;   % 785: fimprintHex:	jr 	$ra			# retorna %
00000198 : 23bdfff8;   % 796: printString:	addi	$sp, $sp, -8			# aloca espaco %
00000199 : afbf0000;   % 797:     		sw	$ra, 0($sp)			# salva $ra %
0000019a : afb00004;   % 798:     		sw	$s0, 4($sp)			# salva $s0 %
0000019b : 00048021;   % 799:     		move	$s0, $a0              		# $s0 = endereco do caractere na string %
0000019c : 82040000;   % 801: loopprintString: lb	$a0, 0($s0)                 	# le em $a0 o caracter a ser impresso %
0000019d : 10800008;   % 802:     		beq     $a0, $zero, fimloopprintString   # string ASCIIZ termina com NULL %
0000019e : 0c0001aa;   % 804:     		jal     printChar       		# imprime char %
0000019f : 20a50008;   % 806: 		addi    $a1, $a1, 8                 	# incrementa a coluna		 %
000001a0 : 28a10139;   % 807: 		blt	$a1, 313, NaoPulaLinha	    	# se ainda tiver lugar na linha %
000001a1 : 14200002;   % 807:  %
000001a2 : 20c60008;   % 808:     		addi    $a2, $a2, 8                 	# incrementa a linha %
000001a3 : 00002821;   % 809:     		move    $a1, $zero			# volta a coluna zero %
000001a4 : 22100001;   % 811: NaoPulaLinha:	addi    $s0, $s0, 1			# proximo caractere %
000001a5 : 0800019c;   % 812:     		j       loopprintString       		# volta ao loop %
000001a6 : 8fbf0000;   % 814: fimloopprintString:	lw      $ra, 0($sp)    		# recupera $ra %
000001a7 : 8fb00000;   % 815: 			lw 	$s0, 0($sp)		# recupera $s0 %
000001a8 : 23bd0008;   % 816:     			addi    $sp, $sp, 8		# libera espaco %
000001a9 : 03e00008;   % 817: fimprintString:		jr      $ra             	# retorna %
000001aa : 30edff00;   % 837: printChar:     andi    $t5, $a3, 0xFF00         # cor fundo %
000001ab : 30ee00ff;   % 838:     	andi    $t6, $a3, 0x00FF             	# cor frente %
000001ac : 000d6a02;   % 839:     	srl     $t5, $t5, 8			# numero da cor de fundo %
000001ad : 28810020;   % 841: 	blt 	$a0, ' ', NAOIMPRIMIVEL		# ascii menor que 32 nao eh imprimivel %
000001ae : 14200004;   % 841:  %
000001af : 2001007e;   % 842: 	bgt	$a0, '~', NAOIMPRIMIVEL		# ascii Maior que 126  nao eh imprimivel %
000001b0 : 0024082a;   % 842:  %
000001b1 : 14200001;   % 842:  %
000001b2 : 080001b4;   % 843:     	j       IMPRIMIVEL %
000001b3 : 24040020;   % 845: NAOIMPRIMIVEL:     li      $a0, 32		# Imprime espaco %
000001b4 : 24010140;   % 847: IMPRIMIVEL:	li	$at, 320		# Num colunas 320 %
000001b5 : 00260018;   % 848:     	mult    $at, $a2			# multiplica $a2x320 %
000001b6 : 00006012;   % 849:     	mflo    $t4				# $t4 = coordenada y %
000001b7 : 01856020;   % 850:     	add     $t4, $t4, $a1               	# $t4 = 320*y + x %
000001b8 : 218c0007;   % 851:     	addi    $t4, $t4, 7                 	# t4 = 320*y + (x+7) %
000001b9 : 3c01ff00;   % 852:     	la      $t8, 0xFF000000          	# Endereco de inicio da memoria VGA %
000001ba : 34380000;   % 852:  %
000001bb : 01986020;   % 853:     	add     $t4, $t4, $t8               	# t4 = endereco de impressao do ultimo pixel da primeira linha do char %
000001bc : 208affe0;   % 854:     	addi    $t2, $a0, -32               	# indice do char na memoria %
000001bd : 000a50c0;   % 855:     	sll     $t2, $t2, 3                 	# offset em bytes em relacao ao endereco inicial %
000001be : 3c019000;   % 856: 	la      $t3, LabelTabChar		# endereco dos caracteres na memoria %
000001bf : 342b0000;   % 856:  %
000001c0 : 014b5020;   % 857:     	add     $t2, $t2, $t3               	# endereco do caractere na memoria %
000001c1 : 8d4b0000;   % 858: 	lw      $t3, 0($t2)                 	# carrega a primeira word do char %
000001c2 : 24080004;   % 859: 	li 	$t0, 4				# i=4 %
000001c3 : 1100000e;   % 861: forChar1I:	beq     $t0, $zero, endForChar1I	# if(i == 0) end for i %
000001c4 : 20090008;   % 862:     		addi    $t1, $zero, 8               	# j = 8 %
000001c5 : 11200009;   % 864: 	forChar1J:      beq     $t1, $zero, endForChar1J    	# if(j == 0) end for j %
000001c6 : 31790001;   % 865:         		andi    $t9, $t3, 0x0001		# primeiro bit do caracter %
000001c7 : 000b5842;   % 866:         		srl     $t3, $t3, 1             	# retira o primeiro bit %
000001c8 : 13200002;   % 867:         		beq     $t9, $zero, printCharPixelbg1	# pixel eh fundo? %
000001c9 : a18e0000;   % 868:         		sb      $t6, 0($t4)             	# imprime pixel com cor de frente %
000001ca : 080001cc;   % 869:         		j       endCharPixel1 %
000001cb : a18d0000;   % 870: printCharPixelbg1:     	sb      $t5, 0($t4)                 	# imprime pixel com cor de fundo %
000001cc : 2129ffff;   % 871: endCharPixel1:     	addi    $t1, $t1, -1                	# j-- %
000001cd : 218cffff;   % 872:     			addi    $t4, $t4, -1                	# t4 aponta um pixel para a esquerda %
000001ce : 080001c5;   % 873:     			j       forChar1J			# vollta novo pixel %
000001cf : 2108ffff;   % 875: endForChar1J: 	addi    $t0, $t0, -1 		# i-- %
000001d0 : 218c0148;   % 876:     		addi    $t4, $t4, 328           # 2**12 + 8 %
000001d1 : 080001c3;   % 877:     		j       forChar1I		# volta ao loop %
000001d2 : 8d4b0004;   % 879: endForChar1I:	lw      $t3, 4($t2)           	# carrega a segunda word do char %
000001d3 : 24080004;   % 880: 		li 	$t0, 4			# i = 4 %
000001d4 : 1100000e;   % 881: forChar2I:     	beq     $t0, $zero, endForChar2I    	# if(i == 0) end for i %
000001d5 : 20090008;   % 882:     		addi    $t1, $zero, 8               # j = 8 %
000001d6 : 11200009;   % 884: 	forChar2J:	beq	$t1, $zero, endForChar2J    	# if(j == 0) end for j %
000001d7 : 31790001;   % 885:         		andi    $t9, $t3, 0x0001	    	# pixel a ser impresso %
000001d8 : 000b5842;   % 886:         		srl     $t3, $t3, 1                 	# desloca para o proximo %
000001d9 : 13200002;   % 887:         		beq     $t9, $zero, printCharPixelbg2	# pixel eh fundo? %
000001da : a18e0000;   % 888:         		sb      $t6, 0($t4)			# imprime cor frente %
000001db : 080001dd;   % 889:         		j       endCharPixel2			# volta ao loop %
000001dc : a18d0000;   % 891: printCharPixelbg2:     	sb      $t5, 0($t4)			# imprime cor de fundo %
000001dd : 2129ffff;   % 893: endCharPixel2:     	addi    $t1, $t1, -1			# j-- %
000001de : 218cffff;   % 894:     			addi    $t4, $t4, -1                	# t4 aponta um pixel para a esquerda %
000001df : 080001d6;   % 895:     			j       forChar2J %
000001e0 : 2108ffff;   % 897: endForChar2J:	addi	$t0, $t0, -1 		# i-- %
000001e1 : 218c0148;   % 898:     		addi    $t4, $t4, 328		# %
000001e2 : 080001d4;   % 899:     		j       forChar2I		# volta ao loop %
000001e3 : 03e00008;   % 901: endForChar2I:	jr $ra				# retorna %
000001e4 : 3c011000;   % 910: <57> bne $gp,0x10008000,readCharKDMMIODE2 %
000001e5 : 34218000;   % 910:  %
000001e6 : 143c0007;   % 910:  %
000001e7 : 3c01ff20;   % 913: readCharKDMMIO:		la 	$t0, 0xFF200000			# Execucao com Polling do KD MMIO %
000001e8 : 34280000;   % 913:  %
000001e9 : 8d020000;   % 915: loopReadCharKDMMIO:  	lw     	$v0, 0($t0)   			# le o bit de flag do teclado %
000001ea : 30420001;   % 916: 			andi 	$v0, $v0, 0x0001		# masacara bit 0 %
000001eb : 1040fffd;   % 917: 			beq     $v0, $zero, loopReadCharKDMMIO  # testa se uma tecla foi pressionada %
000001ec : 8d020004;   % 918:     			lw 	$v0, 4($t0)			# le o ascii da tecla pressionada %
000001ed : 08000212;   % 919: 			j fimreadChar				# fim Read Char %
000001ee : 3c01ff20;   % 923: readCharKDMMIODE2:	la 	$t0, 0xFF200000			# Execucao com Polling do KD MMIO %
000001ef : 34280000;   % 923:  %
000001f0 : 8d020000;   % 925: loopReadCharKDMMIODE2: 	lw     	$v0, 0($t0)   			# le o bit de flag do teclado %
000001f1 : 30420001;   % 926: 			andi 	$v0, $v0, 0x0001		# masacara bit 0 %
000001f2 : 1040fffd;   % 927: 			beq     $v0, $zero, loopReadCharKDMMIODE2  # testa se uma tecla foi pressionada %
000001f3 : 8d020004;   % 928:     			lw 	$v0, 4($t0)			# le o ascii da tecla pressionada %
000001f4 : 08000212;   % 929: 			j fimreadChar				# fim Read Char %
000001f5 : 3c01ff20;   % 936: readCharDE2:  	la      $t0, 0xFF200100 			# Endereco buffer0 %
000001f6 : 34280100;   % 936:  %
000001f7 : 8d090000;   % 937:     		lw     	$t1, 0($t0)				# conteudo inicial do buffer %
000001f8 : 8d0a0000;   % 939: loopReadChar:  	lw     	$t2, 0($t0)   				# le buffer teclado %
000001f9 : 15490002;   % 940: 		bne     $t2, $t1, buffermodificadoChar    	# testa se o buffer foi modificado %
000001fa : 000a4821;   % 942: atualizaBufferChar:  move $t1, $t2			# atualiza o buffer com o novo valor %
000001fb : 080001f8;   % 943:     	j       loopReadChar				# loop de printicpal de leitura  %
000001fc : 314bff00;   % 945: buffermodificadoChar:    andi    $t3, $t2, 0xFF00 	# mascara o 2o scancode %
000001fd : 3c010000;   % 946: 	beq     $t3, 0XF000, teclasoltaChar		# eh 0xF0 no 2o scancode? tecla foi solta %
000001fe : 3421f000;   % 946:  %
000001ff : 102b0006;   % 946:  %
00000200 : 314b00ff;   % 947: 	andi	$t3, $t2, 0xFF				# mascara 1o scancode %
00000201 : 20010012;   % 948:     	bne 	$t3, 0x12, atualizaBufferChar		# nao eh o SHIFT que esta pressionado ? volta a ler  %
00000202 : 142bfff7;   % 948:  %
00000203 : 3c019000;   % 949: 	la      $fp, LabelScanCodeShift			# se for SHIFT que esta pressionado atualiza o endereco da tabel %
00000204 : 343e039e;   % 949:  %
00000205 : 080001fa;   % 950:     	j       atualizaBufferChar			# volta a ler %
00000206 : 314b00ff;   % 952: teclasoltaChar:		andi $t3, $t2, 0x00FF		# mascara o 1o scancode %
00000207 : 20010080;   % 953:   	bgt	$t3, 0x80, atualizaBufferChar		# se o scancode for > 0x80 entao nao eh imprimivel! %
00000208 : 002b082a;   % 953:  %
00000209 : 1420fff0;   % 953:  %
0000020a : 20010012;   % 954: 	bne 	$t3, 0x12, naoehshiftChar		# nao foi o shift que foi solto? entao processa %
0000020b : 142b0003;   % 954:  %
0000020c : 3c019000;   % 955: 	la 	$fp, LabelScanCode			# shift foi solto atualiza o endereco da tabela %
0000020d : 343e0318;   % 955:  %
0000020e : 080001fa;   % 956: 	j 	atualizaBufferChar			# volta a ler %
0000020f : 03cb5820;   % 958: naoehshiftChar:	   	add     $t3, $fp, $t3                   	# endereco na tabela de scancode da tecla com ou sem shift %
00000210 : 81620000;   % 959:     	lb      $v0, 0($t3)				# le o ascii do caracter para $v0 %
00000211 : 1040ffe8;   % 960:     	beq     $v0, $zero, atualizaBufferChar		# se for caractere nao imprimivel volta a ler %
00000212 : 03e00008;   % 962: fimreadChar: 	jr   $ra				# retorna %
00000213 : 23bdfffc;   % 974: readString: 	addi 	$sp, $sp, -4			# reserva espaco na pilha %
00000214 : afbf0000;   % 975: 		sw 	$ra, 0($sp)			# salva $ra %
00000215 : 24030000;   % 976: 		li 	$v1, 0				# zera o contador de caracteres digitados %
00000216 : 3c019000;   % 977:     		la      $fp, LabelScanCode      	# Endereco da tabela de scancode inicial para readChar %
00000217 : 343e0318;   % 977:  %
00000218 : 10a30009;   % 979: loopreadString: beq 	$a1, $v1, fimreadString   	# buffer cheio fim %
00000219 : 001fc821;   % 980: 		move 	$t9, $ra			# salva $ra %
0000021a : 0c0001e4;   % 981: 		jal 	readChar			# le um caracter do teclado (retorno em $v0) %
0000021b : 0019f821;   % 982: 		move 	$ra, $t9			# recupera $ra %
0000021c : 2001000a;   % 983: 		beq 	$v0, 0x0A, fimreadString	# se for tecla ENTER fim %
0000021d : 10220004;   % 983:  %
0000021e : a0820000;   % 984: 		sb 	$v0, 0($a0)			# grava no buffer %
0000021f : 20630001;   % 985: 		addi 	$v1, $v1, 1			# incrementa contador %
00000220 : 20840001;   % 986: 		addi 	$a0, $a0, 1			# incrementa endereco no buffer %
00000221 : 08000218;   % 987: 		j loopreadString			# volta a ler outro caractere %
00000222 : a0800000;   % 989: fimreadString: 	sb 	$zero, 0($a0)			# grava NULL no buffer %
00000223 : 2082ffff;   % 990: 		addi 	$v0, $a0, -1			# Para que $v0 tenha o endereco do ultimo caractere digitado %
00000224 : 8fbf0000;   % 991: 		lw 	$ra, 0($sp)			# recupera $ra %
00000225 : 23bd0004;   % 992: 		addi 	$sp, $sp, 4			# libera espaco %
00000226 : 03e00008;   % 993: 		jr 	$ra				# retorna %
00000227 : 23bdfffc;   % 1002: readInt: 	addi 	$sp,$sp,-4		# reserva espaco na pilha %
00000228 : afbf0000;   % 1003: 	sw 	$ra, 0($sp)			# salva $ra %
00000229 : 3c019000;   % 1004: 	la 	$a0, TempBuffer			# Endereco do buffer de string %
0000022a : 3424044c;   % 1004:  %
0000022b : 2405000a;   % 1005: 	li 	$a1, 10				# numero maximo de digitos %
0000022c : 0c000213;   % 1006: 	jal 	readString			# le uma string de ate 10 digitos, $v1 numero de digitos %
0000022d : 00024021;   % 1007: 	move 	$t0, $v0			# copia endereco do ultimo digito %
0000022e : 240a000a;   % 1008: 	li 	$t2, 10				# dez %
0000022f : 240b0001;   % 1009: 	li 	$t3, 1				# dezenas, centenas, etc %
00000230 : 00001021;   % 1010: 	move 	$v0, $zero			# zera o numero %
00000231 : 10600015;   % 1012: loopReadInt: 	beq	$v1,$zero, fimReadInt	# Leu todos os digitos %
00000232 : 91090000;   % 1013: 	lbu 	$t1, ($t0)			# le um digito %
00000233 : 2001002d;   % 1014: 	beq 	$t1, 0x2d, ehnegReadInt		# = '-' %
00000234 : 10290011;   % 1014:  %
00000235 : 2001002b;   % 1015: 	beq 	$t1, 0x2b, ehposReadInt		# = '+' %
00000236 : 10290010;   % 1015:  %
00000237 : 29210030;   % 1016: 	blt 	$t1, 0x30, naoehReadInt		# <'0' %
00000238 : 1420000c;   % 1016:  %
00000239 : 20010039;   % 1017: 	bgt 	$t1, 0x39, naoehReadInt		# >'9' %
0000023a : 0029082a;   % 1017:  %
0000023b : 14200009;   % 1017:  %
0000023c : 2129ffd0;   % 1018: 	addi 	$t1, $t1, -48			# transforma ascii em numero %
0000023d : 012b0018;   % 1019: 	mult 	$t1, $t3			# multiplica por dezenas/centenas %
0000023e : 00004812;   % 1020: 	mflo 	$t1				# resultado LO da mult %
0000023f : 00491020;   % 1021: 	add 	$v0, $v0, $t1			# soma no numero %
00000240 : 016a0018;   % 1022: 	mult 	$t3, $t2			# proxima dezena/centena %
00000241 : 00005812;   % 1023: 	mflo 	$t3				# resultado LO da mult %
00000242 : 2108ffff;   % 1024: 	addi 	$t0, $t0, -1			# busca o digito anterior %
00000243 : 2063ffff;   % 1025: 	addi	$v1, $v1, -1			# reduz o contador de digitos  %
00000244 : 08000231;   % 1026: 	j loopReadInt				# volta para buscar proximo digito %
00000245 : 08000056;   % 1028: naoehReadInt:	j instructionException		# gera erro "instruçao" invalida %
00000246 : 00021022;   % 1030: ehnegReadInt:	sub $v0,$zero,$v0		# se for negativo %
00000247 : 8fbf0000;   % 1034: fimReadInt:	lw 	$ra, 0($sp)		# recupera $ra %
00000248 : 23bd0004;   % 1035: 	addi 	$sp, $sp, 4			# libera espaco %
00000249 : 03e00008;   % 1036: 	jr 	$ra				# fim ReadInt %
0000024a : 3c011000;   % 1055: <57> bne $gp,0x10008000,midiOutDE2 %
0000024b : 34218000;   % 1055:  %
0000024c : 143c0003;   % 1055:  %
0000024d : 2402001f;   % 1056: 	li $v0,31		# Chama o syscall normal %
0000024e : 0000000c;   % 1057: 	syscall %
0000024f : 08000264;   % 1058: 	j fimmidiOut %
00000250 : 3c01ff20;   % 1060: midiOutDE2:	la      $t0, 0xFF200178 %
00000251 : 34280178;   % 1060:  %
00000252 : 00004820;   % 1061:     		add     $t1, $zero, $zero %
00000253 : 30ca000f;   % 1066:    	 	andi    $t2, $a2, 0x0000000F %
00000254 : 000a56c0;   % 1067:     		sll     $t2, $t2, 27 %
00000255 : 012a4825;   % 1068:     		or      $t1, $t1, $t2 %
00000256 : 30ea007f;   % 1071:     		andi    $t2, $a3, 0x0000007F %
00000257 : 000a5500;   % 1072:     		sll     $t2, $t2, 20 %
00000258 : 012a4825;   % 1073:     		or      $t1, $t1, $t2 %
00000259 : 308a007f;   % 1076:     		andi    $t2, $a0, 0x0000007F %
0000025a : 000a5340;   % 1077:     		sll     $t2, $t2, 13 %
0000025b : 012a4825;   % 1078:     		or      $t1, $t1, $t2 %
0000025c : 30aa1fff;   % 1081:     		andi    $t2, $a1, 0x00001FFF %
0000025d : 012a4825;   % 1082:     		or      $t1, $t1, $t2 %
0000025e : 0800025f;   % 1085:     		j       SintMidOut %
0000025f : ad090000;   % 1087: SintMidOut:	sw	$t1, 0($t0) %
00000260 : 3c01ff20;   % 1090: 	    		la      $t2, 0xFF20017C %
00000261 : 342a017c;   % 1090:  %
00000262 : 8d4b0000;   % 1091: Check_AUD_DACLRCK:     	lw      $t3, 0($t2) %
00000263 : 1160fffe;   % 1092:     			beq     $t3, $zero, Check_AUD_DACLRCK %
00000264 : 03e00008;   % 1094: fimmidiOut:    		jr      $ra %
00000265 : 3c011000;   % 1111: <57> bne $gp,0x10008000,midiOutSyncDE2 %
00000266 : 34218000;   % 1111:  %
00000267 : 143c0003;   % 1111:  %
00000268 : 24020021;   % 1112: 	li $v0,33		# Chama o syscall normal %
00000269 : 0000000c;   % 1113: 	syscall %
0000026a : 08000286;   % 1114: 	j fimmidiOutSync %
0000026b : 3c01ff20;   % 1116: midiOutSyncDE2:	la      $t0, 0xFF200178 %
0000026c : 34280178;   % 1116:  %
0000026d : 00004820;   % 1117:     		add     $t1, $zero, $zero %
0000026e : 3c018000;   % 1120:     		ori     $t1, $t1, 0x80000000 %
0000026f : 34210000;   % 1120:  %
00000270 : 01214825;   % 1120:  %
00000271 : 30ca000f;   % 1123:     		andi    $t2, $a2, 0x0000000F %
00000272 : 000a56c0;   % 1124:     		sll     $t2, $t2, 27 %
00000273 : 012a4825;   % 1125:     		or      $t1, $t1, $t2 %
00000274 : 30ea007f;   % 1128:     		andi    $t2, $a3, 0x0000007F %
00000275 : 000a5500;   % 1129:     		sll     $t2, $t2, 20 %
00000276 : 012a4825;   % 1130:     		or      $t1, $t1, $t2 %
00000277 : 308a007f;   % 1133:     		andi    $t2, $a0, 0x0000007F %
00000278 : 000a5340;   % 1134:     		sll     $t2, $t2, 13 %
00000279 : 012a4825;   % 1135:     		or      $t1, $t1, $t2 %
0000027a : 30aa1fff;   % 1138:     		andi    $t2, $a1, 0x00001FFF %
0000027b : 012a4825;   % 1139:     		or      $t1, $t1, $t2 %
0000027c : 0800027d;   % 1142:     		j       SintMidOutSync %
0000027d : ad090000;   % 1144: SintMidOutSync:	sw	$t1, 0($t0) %
0000027e : 3c01ff20;   % 1147:     		la      $t2, 0xFF20017C %
0000027f : 342a017c;   % 1147:  %
00000280 : 3c01ff20;   % 1148:     		la      $t4, 0xFF200180 %
00000281 : 342c0180;   % 1148:  %
00000282 : 8d4b0000;   % 1150: Check_AUD_DACLRCKSync:	lw      $t3, 0($t2) %
00000283 : 1160fffe;   % 1151:     			beq     $t3, $zero, Check_AUD_DACLRCKSync %
00000284 : 8d8d0000;   % 1153: Melody:     	lw      $t5, 0($t4) %
00000285 : 15a0fffe;   % 1154:     		bne     $t5, $zero, Melody %
00000286 : 03e00008;   % 1156: fimmidiOutSync:	jr      $ra %
00000287 : 23bdfff4;   % 1165: popEvent:     addi    $sp, $sp, -12 %
00000288 : afa40000;   % 1166:     sw      $a0, 0($sp) %
00000289 : afb00004;   % 1167:     sw      $s0, 4($sp) %
0000028a : afbf0008;   % 1168:     sw      $ra, 8($sp) %
0000028b : 3c019000;   % 1171:     la      $s0, eventQueueBeginPtr %
0000028c : 3430069c;   % 1171:  %
0000028d : 8e1a0000;   % 1172:     lw      $k0, 0($s0) %
0000028e : 3c019000;   % 1173:     la      $k1, eventQueueEndPtr %
0000028f : 343b06a0;   % 1173:  %
00000290 : 8f7b0000;   % 1174:     lw      $k1, 0($k1) %
00000291 : 24020000;   % 1175:     li      $v0, 0 %
00000292 : 135b0005;   % 1176:     beq     $k0, $k1, popEventEnd %
00000293 : 001a2021;   % 1179:     move    $a0, $k0 %
00000294 : 0c00004c;   % 1180:     jal     eventQueueIncrementPointer %
00000295 : ae020000;   % 1181:     sw      $v0, 0($s0) %
00000296 : 24020001;   % 1182:     li      $v0, 1 %
00000297 : 8f430000;   % 1183:     lw      $v1, 0($k0) %
00000298 : 8fbf0008;   % 1185: popEventEnd:     lw      $ra, 8($sp) %
00000299 : 8fb00004;   % 1186:     lw      $s0, 4($sp) %
0000029a : 8fa40000;   % 1187:     lw      $a0, 0($sp) %
0000029b : 23bd000c;   % 1188:     addi    $sp, $sp, 12 %
0000029c : 03e00008;   % 1189:     jr      $ra %
0000029d : 23bdfffc;   % 1201: printFloat:	addi 	$sp, $sp, -4 %
0000029e : afbf0000;   % 1202: 		sw 	$ra, 0($sp) %
0000029f : 3c019000;   % 1203: 		la 	$s0, TempBuffer %
000002a0 : 3430044c;   % 1203:  %
000002a1 : 2408002b;   % 1206: 		li 	$t0, '+'			# define sinal '+' %
000002a2 : 44116000;   % 1207: 		mfc1 	$s1, $f12			# recupera o numero float %
000002a3 : 3c018000;   % 1208: 		andi 	$s1, $s1, 0x80000000		# mascara com 1000 %
000002a4 : 34210000;   % 1208:  %
000002a5 : 02218824;   % 1208:  %
000002a6 : 12200002;   % 1209: 		beq 	$s1, $zero, ehposprintFloat	# eh positivo $s0=0 %
000002a7 : 24110001;   % 1210: 		li 	$s1, 1				# numero eh negativo $s0=1 %
000002a8 : 2408002d;   % 1211: 		li 	$t0, '-'			# define sinal '-' %
000002a9 : a2080000;   % 1212: ehposprintFloat: sb 	$t0, 0($s0)			# coloca sinal no buffer %
000002aa : 22100001;   % 1213: 		addi 	$s0, $s0,1			# incrementa o endereco do buffer %
000002ab : 44086000;   % 1216: 		 mfc1 	$t0, $f12			# recupera o numero float %
000002ac : 3c017f80;   % 1217: 		 andi 	$t0, $t0, 0x7F800000   		# mascara com 0111 1111 1000 0000 0000 0000... %
000002ad : 34210000;   % 1217:  %
000002ae : 01014024;   % 1217:  %
000002af : 00084040;   % 1218: 		 sll 	$t0, $t0, 1			# tira o sinal do numero %
000002b0 : 00084602;   % 1219: 		 srl 	$t0, $t0, 24			# recupera o expoente %
000002b1 : 44096000;   % 1222: 		mfc1 	$t1, $f12			# recupera o numero float  %
000002b2 : 3c01007f;   % 1223: 		andi 	$t1, $t1, 0x007FFFFF		# mascara com 0000 0000 0111 1111 1111... 		  %
000002b3 : 3421ffff;   % 1223:  %
000002b4 : 01214824;   % 1223:  %
000002b5 : 11000049;   % 1225: 		beq 	$t0, $zero, ehExp0printFloat	# Expoente = 0 %
000002b6 : 200100ff;   % 1226: 		beq 	$t0, 255, ehExp255printFloat	# Expoente = 255 %
000002b7 : 10280051;   % 1226:  %
000002b8 : 46006005;   % 1230: 		abs.s 	$f0, $f12		# $f0 recebe o módulo  de x %
000002b9 : 3c083f80;   % 1231: 		lui 	$t0, 0x3F80 %
000002ba : 44880800;   % 1232: 		mtc1 	$t0, $f1		# $f1 recebe o numero 1.0 %
000002bb : 3c084120;   % 1233: 		lui 	$t0, 0x4120 %
000002bc : 44885000;   % 1234: 		mtc1 	$t0, $f10		# $f10 recebe o numero 10.0 %
000002bd : 4601013c;   % 1236: 		c.lt.s 	1, $f0, $f1		# $f0 < 1.0 ? Flag 1 indica se $f0<1 ou seja E deve ser negativo %
000002be : 45050002;   % 1237: 		bc1t 	1, menor1printFloat %
000002bf : 46005086;   % 1238: 		mov.s 	$f2, $f10		# $f2  fator de multiplicaçao = 10 %
000002c0 : 080002cb;   % 1239: 		j 	cont2printFloat		# vai para expoente positivo %
000002c1 : 460a0883;   % 1240: menor1printFloat: div.s $f2,$f1,$f10		# $f2 fator multiplicativo = 0.1 %
000002c2 : 46000106;   % 1243: cont1printFloat: 	mov.s 	$f4, $f0			# inicia com o numero x  %
000002c3 : 460008c6;   % 1244: 		 	mov.s 	$f3, $f1			# contador começa em 1 %
000002c4 : 46022103;   % 1245: loop1printFloat: 	div.s 	$f4, $f4, $f2			# divide o numero pelo fator multiplicativo %
000002c5 : 4601203e;   % 1246: 		 	c.le.s 	0, $f4, $f1			# o numero eh > que 1? entao fim %
000002c6 : 45000002;   % 1247: 		 	bc1f 	0, fimloop1printFloat %
000002c7 : 460118c0;   % 1248: 		 	add.s 	$f3, $f3, $f1			# incrementa o contador %
000002c8 : 080002c4;   % 1249: 		 	j 	loop1printFloat			# volta ao loop %
000002c9 : 46022103;   % 1250: fimloop1printFloat: 	div.s 	$f4, $f4, $f2			# ajusta o numero %
000002ca : 080002d2;   % 1251: 		 	j 	intprintFloat			# vai para imprimir a parte inteira %
000002cb : 46000106;   % 1254: cont2printFloat:	mov.s 	$f4, $f0			# inicia com o numero x  %
000002cc : 44801800;   % 1255: 		 	mtc1 	$zero, $f3			# contador começa em 0 %
000002cd : 460a203c;   % 1256: loop2printFloat:  	c.lt.s 	0, $f4, $f10			# resultado eh < que 10? entao fim %
000002ce : 46022103;   % 1257: 		 	div.s 	$f4, $f4, $f2			# divide o numero pelo fator multiplicativo %
000002cf : 45010002;   % 1258: 		 	bc1t 	0 ,intprintFloat %
000002d0 : 460118c0;   % 1259: 		 	add.s 	$f3, $f3, $f1			# incrementa o contador %
000002d1 : 080002cd;   % 1260: 		 	j 	loop2printFloat %
000002d2 : 46022102;   % 1266: intprintFloat:		mul.s 		$f4, $f4, $f2		# ajusta o numero %
000002d3 : 4600214f;   % 1267: 		  	floor.w.s 	$f5, $f4		# menor inteiro %
000002d4 : 44082800;   % 1268: 		  	mfc1 		$t0, $f5		# passa para $t5 %
000002d5 : 21080030;   % 1269: 		  	addi 		$t0, $t0, 48		# converte para ascii %
000002d6 : a2080000;   % 1270: 		  	sb 		$t0, 0($s0)		# coloca no buffer %
000002d7 : 22100001;   % 1271: 		  	addi 		$s0, $s0, 1		# incrementta o buffer %
000002d8 : 2408002e;   % 1274: 		  	li 	$t0, '.'			# carrega o '.' %
000002d9 : a2080000;   % 1275: 		  	sb 	$t0, 0($s0)			# coloca no buffer %
000002da : 22100001;   % 1276: 		  	addi 	$s0, $s0, 1			# incrementa o buffer %
000002db : 24090008;   % 1279: 		  	li 		$t1, 8				# contador de digitos  -  8 casas decimais %
000002dc : 1120000c;   % 1280: loopfracprintFloat:  	beq 		$t1, $zero, fimfracprintFloat	# fim dos digitos? %
000002dd : 4600214f;   % 1281: 		  	floor.w.s 	$f5, $f4			# menor inteiro %
000002de : 46802960;   % 1282: 		  	cvt.s.w 	$f5, $f5			# parte inteira		 %
000002df : 46052141;   % 1283: 		  	sub.s 		$f5, $f4, $f5			# parte fracionaria %
000002e0 : 460a2942;   % 1284: 		  	mul.s 		$f5, $f5, $f10			# mult x 10 %
000002e1 : 4600298f;   % 1285: 		  	floor.w.s 	$f6, $f5			# converte para inteiro %
000002e2 : 44083000;   % 1286: 		  	mfc1 		$t0, $f6			# passa para $t0 %
000002e3 : 21080030;   % 1287: 		  	addi 		$t0, $t0, 48			# converte para ascii %
000002e4 : a2080000;   % 1288: 		  	sb 		$t0, 0($s0)			# coloca no buffer %
000002e5 : 22100001;   % 1289: 		  	addi 		$s0, $s0, 1			# incrementa endereco %
000002e6 : 2129ffff;   % 1290: 		  	addi 		$t1, $t1, -1			# decrementa contador %
000002e7 : 46002906;   % 1291: 		  	mov.s 		$f4, $f5			# coloca o numero em $f4 %
000002e8 : 080002dc;   % 1292: 		  	j 		loopfracprintFloat		# volta ao loop %
000002e9 : 24080045;   % 1295: fimfracprintFloat: 	li 	$t0,'E'			# carrega 'E' %
000002ea : a2080000;   % 1296: 			sb 	$t0, 0($s0)		# coloca no buffer %
000002eb : 22100001;   % 1297: 			addi 	$s0, $s0, 1		# incrementa endereco %
000002ec : 2408002b;   % 1300: 		  	li 	$t0, '+'				# carrega '+' %
000002ed : 45040001;   % 1301: 		  	bc1f 	1, expposprintFloat			# nao eh negativo? %
000002ee : 2408002d;   % 1302: 		  	li 	$t0, '-'				# carrega '-' %
000002ef : a2080000;   % 1303: expposprintFloat: 	sb 	$t0, 0($s0)				# coloca no buffer %
000002f0 : 22100001;   % 1304: 		  	addi 	$s0, $s0, 1				#incrementa endereco %
000002f1 : 2409000a;   % 1307: 			li 	$t1, 10				# carrega 10 %
000002f2 : 460018e4;   % 1308: 			cvt.w.s $f3, $f3			# converte $f3 em inteiro	 %
000002f3 : 44081800;   % 1309: 			mfc1 	$t0, $f3			# passa $f3 para $t0 %
000002f4 : 0109001a;   % 1310: 			div 	$t0, $t1			# divide por 10 %
000002f5 : 00004012;   % 1311: 			mflo 	$t0				# quociente (dezena) %
000002f6 : 21080030;   % 1312: 			addi 	$t0, $t0, 48			# converte para ascii %
000002f7 : a2080000;   % 1313: 			sb 	$t0, 0($s0)			# coloca no buffer %
000002f8 : 00004010;   % 1314: 			mfhi 	$t0				# resto (unidade) %
000002f9 : 21080030;   % 1315: 			addi 	$t0, $t0, 48			# converte para ascii %
000002fa : a2080001;   % 1316: 			sb 	$t0, 1($s0)			# coloca no buffer %
000002fb : a2000002;   % 1317: 			sb 	$zero, 2($s0)			# insere \NULL da string %
000002fc : 3c019000;   % 1318: 			la 	$a0, TempBuffer			# endereco do Buffer										 %
000002fd : 3424044c;   % 1318:  %
000002fe : 08000312;   % 1319: 	  		j 	fimprintFloat			# imprime a string %
000002ff : 11200006;   % 1321: ehExp0printFloat: 	beq 	$t1, $zero, eh0printFloat	# Verifica se eh zero %
00000300 : 3c019000;   % 1323: ehDesnormprintFloat: 	la 	$a0, NumDesnormP		# string numero desnormalizado positivo %
00000301 : 34240658;   % 1323:  %
00000302 : 1220000f;   % 1324: 			beq 	$s1, $zero, fimprintFloat	# o sinal eh 1? entao é negativo %
00000303 : 3c019000;   % 1325: 		 	la 	$a0, NumDesnormN		# string numero desnormalizado negativo %
00000304 : 34240661;   % 1325:  %
00000305 : 08000312;   % 1326: 			j 	fimprintFloat			# imprime a string %
00000306 : 3c019000;   % 1328: eh0printFloat:		la 	$a0, NumZero			# string do zero %
00000307 : 3424066a;   % 1328:  %
00000308 : 08000312;   % 1329: 			j 	fimprintFloat 	 		# imprime a string %
00000309 : 11200003;   % 1331: ehExp255printFloat: 	beq 	$t1, $zero, ehInfprintFloat	# se mantissa eh zero entao eh Infinito %
0000030a : 3c019000;   % 1333: ehNaNprintfFloat:	la 	$a0, NumNaN			# string do NaN %
0000030b : 34240689;   % 1333:  %
0000030c : 08000312;   % 1334: 			j 	fimprintFloat			# imprime string %
0000030d : 3c019000;   % 1336: ehInfprintFloat:	la 	$a0, NumInfP			# string do infinito positivo %
0000030e : 34240675;   % 1336:  %
0000030f : 12200002;   % 1337: 			beq 	$s1, $zero, fimprintFloat	# o sinal eh 1? entao eh negativo %
00000310 : 3c019000;   % 1338: 			la 	$a0, NumInfN			# string do infinito negativo %
00000311 : 3424067f;   % 1338:  %
00000312 : 0c000198;   % 1341: fimprintFloat:		jal 	printString			# imprime a string em $a0 %
00000313 : 8fbf0000;   % 1342: 			lw 	$ra, 0($sp)			# recupera $ra %
00000314 : 23bd0004;   % 1343: 			addi 	$sp, $sp, 4			# libera sepaco %
00000315 : 03e00008;   % 1344: 			jr 	$ra				# retorna %
00000316 : 23bdfffc;   % 1353: readFloat: addi $sp, $sp, -4			# aloca espaco %
00000317 : afbf0000;   % 1354: 	sw 	$ra, 0($sp)			# salva $ra %
00000318 : 3c019000;   % 1355: 	la 	$a0, TempBuffer			# endereco do FloatBuffer %
00000319 : 3424044c;   % 1355:  %
0000031a : 24050020;   % 1356: 	li 	$a1, 32				# numero maximo de caracteres %
0000031b : 0c000213;   % 1357: 	jal	readString			# le string, retorna $v0 ultimo endereco e $v1 numero de caracteres %
0000031c : 00028021;   % 1358: 	move 	$s0, $v0			# ultimo endereco da string (antes do \0) %
0000031d : 00038821;   % 1359: 	move 	$s1, $v1			# numero de caracteres digitados %
0000031e : 3c019000;   % 1360: 	la	$s7, TempBuffer			# Endereco do primeiro caractere %
0000031f : 3437044c;   % 1360:  %
00000320 : 00174021;   % 1362: lePrimeiroreadFloat:	move 	$t0, $s7		# Endereco de Inicio %
00000321 : 81090000;   % 1363: 	lb 	$t1, 0($t0)				# le primeiro caractere %
00000322 : 20010065;   % 1364: 	beq 	$t1, 'e', insere0AreadFloat		# insere '0' antes %
00000323 : 1029000b;   % 1364:  %
00000324 : 20010045;   % 1365: 	beq 	$t1, 'E', insere0AreadFloat		# insere '0' antes %
00000325 : 10290009;   % 1365:  %
00000326 : 2001002e;   % 1366: 	beq 	$t1, '.', insere0AreadFloat		#  insere '0' antes %
00000327 : 10290007;   % 1366:  %
00000328 : 2001002b;   % 1367: 	beq 	$t1, '+', pulaPrimreadChar		# pula o primeiro caractere %
00000329 : 10290003;   % 1367:  %
0000032a : 2001002d;   % 1368: 	beq 	$t1, '-', pulaPrimreadChar %
0000032b : 10290001;   % 1368:  %
0000032c : 0800033b;   % 1369: 	j leUltimoreadFloat %
0000032d : 22f70001;   % 1371: pulaPrimreadChar: addi $s7,$s7,1		# incrementa o endereco inicial %
0000032e : 08000320;   % 1372: 		  j lePrimeiroreadFloat		# volta a testar o novo primeiro caractere %
0000032f : 00104021;   % 1374: insere0AreadFloat: move $t0, $s0		# endereco do ultimo caractere %
00000330 : 22100001;   % 1375: 		   addi $s0, $s0, 1		# desloca o ultimo endereco para o proximo %
00000331 : 22310001;   % 1376: 	   	   addi $s1, $s1, 1		# incrementa o num. caracteres %
00000332 : a2000001;   % 1377: 	   	   sb 	$zero, 1($s0)		# \NULL do final de string %
00000333 : 0017c021;   % 1378: 	   	   move $t8, $s7		# primeiro caractere %
00000334 : 11180004;   % 1379: insere0Aloop:	   beq 	$t0, $t8, saiinsere0AreadFloat	# chegou no inicio entao fim %
00000335 : 81090000;   % 1380: 		   lb 	$t1, 0($t0)		# le caractere %
00000336 : a1090001;   % 1381: 		   sb 	$t1, 1($t0)		# escreve no proximo %
00000337 : 2108ffff;   % 1382: 		   addi $t0, $t0, -1		# decrementa endereco %
00000338 : 08000334;   % 1383: 		   j insere0Aloop		# volta ao loop %
00000339 : 24090030;   % 1384: saiinsere0AreadFloat: li $t1, '0'		# ascii '0' %
0000033a : a1090000;   % 1385: 		   sb $t1, 0($t0)		# escreve '0' no primeiro caractere %
0000033b : 82090000;   % 1387: leUltimoreadFloat: lb  	$t1,0($s0)			# le ultimo caractere %
0000033c : 20010065;   % 1388: 		beq 	$t1,'e', insere0PreadFloat	# insere '0' depois %
0000033d : 10290005;   % 1388:  %
0000033e : 20010045;   % 1389: 		beq 	$t1,'E', insere0PreadFloat	# insere '0' depois %
0000033f : 10290003;   % 1389:  %
00000340 : 2001002e;   % 1390: 		beq 	$t1,'.', insere0PreadFloat	# insere '0' depois %
00000341 : 10290001;   % 1390:  %
00000342 : 08000348;   % 1391: 		j 	inicioreadFloat %
00000343 : 22100001;   % 1393: insere0PreadFloat: addi	$s0, $s0, 1		# desloca o ultimo endereco para o proximo %
00000344 : 22310001;   % 1394: 	   	   addi	$s1, $s1, 1		# incrementa o num. caracteres %
00000345 : 24090030;   % 1395: 		   li 	$t1,'0'			# ascii '0' %
00000346 : a2090000;   % 1396: 		   sb 	$t1,0($s0)		# escreve '0' no ultimo %
00000347 : a2000001;   % 1397: 		   sb 	$zero,1($s0)		# \null do final de string %
00000348 : 44800000;   % 1399: inicioreadFloat:  mtc1 	$zero,$f0		# $f0 Resultado inicialmente zero %
00000349 : 2408000a;   % 1400: 		li 	$t0, 10			# inteiro 10	 %
0000034a : 44885000;   % 1401: 		mtc1 	$t0, $f10		# passa para o C1 %
0000034b : 468052a0;   % 1402: 		cvt.s.w $f10, $f10		# $f10 contem sempre o numero cte 10.0000 %
0000034c : 24080001;   % 1403: 		li 	$t0, 1			# inteiro 1 %
0000034d : 44880800;   % 1404: 		mtc1 	$t0, $f1		# passa para o C1 %
0000034e : 46800860;   % 1405: 		cvt.s.w $f1, $f1		# $f1 contem sempre o numero cte 1.0000 %
0000034f : 22130001;   % 1408: procuraEreadFloat:	add 	$s3, $s0, 1			# inicialmente nao tem 'e' ou 'E' na string (fora da string) %
00000350 : 00174021;   % 1409: 			move 	$t0, $s7			# endereco inicial %
00000351 : 11100008;   % 1410: loopEreadFloat: 	beq 	$t0, $s0, naotemEreadFloat	# sai se nao encontrou 'e' %
00000352 : 81090000;   % 1411: 			lb 	$t1, 0($t0)			# le o caractere %
00000353 : 20010065;   % 1412: 			beq 	$t1, 'e', ehEreadFloat		# tem 'e' %
00000354 : 10290004;   % 1412:  %
00000355 : 20010045;   % 1413: 			beq	$t1, 'E', ehEreadFloat		# tem 'E' %
00000356 : 10290002;   % 1413:  %
00000357 : 21080001;   % 1414: 			addi 	$t0, $t0, 1			# incrementa endereco %
00000358 : 08000351;   % 1415: 			j 	loopEreadFloat			# volta ao loop %
00000359 : 00089821;   % 1416: ehEreadFloat: 		move 	$s3, $t0			# endereco do 'e' ou 'E' na string %
0000035a : 00139021;   % 1420: procuraPontoreadFloat:	move 	$s2, $s3			# local inicial do ponto na string (='e' se existir) ou fora da string	 %
0000035b : 00174021;   % 1421: 			move 	$t0, $s7			# endereco inicial %
0000035c : 11100006;   % 1422: loopPontoreadFloat: 	beq 	$t0, $s0, naotemPontoreadFloat	# sai se nao encontrou '.' %
0000035d : 81090000;   % 1423: 			lb 	$t1, 0($t0)			# le o caractere %
0000035e : 2001002e;   % 1424: 			beq 	$t1, '.', ehPontoreadFloat	# tem '.' %
0000035f : 10290002;   % 1424:  %
00000360 : 21080001;   % 1425: 			addi 	$t0, $t0, 1			# incrementa endereco %
00000361 : 0800035c;   % 1426: 			j 	loopPontoreadFloat		# volta ao loop %
00000362 : 00089021;   % 1427: ehPontoreadFloat: 	move 	$s2, $t0			# endereco do '.' na string %
00000363 : 44801000;   % 1431: intreadFloat:		mtc1 	$zero, $f2			# zera parte inteira %
00000364 : 2248ffff;   % 1432: 			addi 	$t0, $s2, -1			# endereco do caractere antes do ponto %
00000365 : 460008c6;   % 1433: 			mov.s 	$f3, $f1			# $f3 contem unidade/dezenas/centenas		 %
00000366 : 0017c021;   % 1434: 			move 	$t8, $s7			# Primeiro Endereco %
00000367 : 0118082a;   % 1435: loopintreadFloat: 	blt 	$t0, $t8, fimintreadFloat	# sai se o enderefo for < inicio da string %
00000368 : 1420000e;   % 1435:  %
00000369 : 81090000;   % 1436: 			lb 	$t1, 0($t0)			# le o caracter %
0000036a : 29210030;   % 1437: 			blt 	$t1, '0', erroreadFloat		# nao eh caractere valido para numero %
0000036b : 1420004b;   % 1437:  %
0000036c : 20010039;   % 1438: 			bgt 	$t1, '9', erroreadFloat		# nao eh caractere valido para numero %
0000036d : 0029082a;   % 1438:  %
0000036e : 14200048;   % 1438:  %
0000036f : 2129ffd0;   % 1439: 			addi 	$t1, $t1, -48			# converte ascii para decimal %
00000370 : 44891000;   % 1440: 			mtc1 	$t1, $f2			# passa para 0 C1 %
00000371 : 468010a0;   % 1441: 			cvt.s.w $f2, $f2			# digito lido em float %
00000372 : 46031082;   % 1443: 			mul.s 	$f2,$f2,$f3			# multiplcica por un/dezena/centena %
00000373 : 46020000;   % 1444: 			add.s 	$f0,$f0,$f2			# soma no resultado %
00000374 : 460a18c2;   % 1445: 			mul.s 	$f3,$f3,$f10			# proxima dezena/centena %
00000375 : 2108ffff;   % 1447: 			add $t0,$t0,-1				# endereco anterior %
00000376 : 08000367;   % 1448: 			j loopintreadFloat			# volta ao loop %
00000377 : 44801000;   % 1452: fracreadFloat:		mtc1 	$zero, $f2			# zera parte fracionaria %
00000378 : 22480001;   % 1453: 			addi 	$t0, $s2, 1			# endereco depois do ponto %
00000379 : 460a08c3;   % 1454: 			div.s 	$f3, $f1, $f10			# $f3 inicial 0.1 %
0000037a : 0113082a;   % 1456: loopfracreadFloat: 	bge 	$t0, $s3, fimfracreadFloat	# endereco eh 'e' 'E' ou >ultimo %
0000037b : 1020000e;   % 1456:  %
0000037c : 81090000;   % 1457: 			lb 	$t1, 0($t0)			# le o caracter %
0000037d : 29210030;   % 1458: 			blt 	$t1, '0', erroreadFloat		# nao eh valido %
0000037e : 14200038;   % 1458:  %
0000037f : 20010039;   % 1459: 			bgt 	$t1, '9', erroreadFloat		# nao eh valido %
00000380 : 0029082a;   % 1459:  %
00000381 : 14200035;   % 1459:  %
00000382 : 2129ffd0;   % 1460: 			addi 	$t1, $t1, -48			# converte ascii para decimal %
00000383 : 44891000;   % 1461: 			mtc1 	$t1, $f2			# passa para C1				 %
00000384 : 468010a0;   % 1462: 			cvt.s.w $f2, $f2			# digito lido em float %
00000385 : 46031082;   % 1464: 			mul.s 	$f2, $f2, $f3			# multiplica por ezena/centena %
00000386 : 46020000;   % 1465: 			add.s 	$f0, $f0, $f2			# soma no resultado %
00000387 : 460a18c3;   % 1466: 			div.s 	$f3, $f3, $f10			# proxima frac un/dezena/centena %
00000388 : 21080001;   % 1468: 			addi 	$t0, $t0, 1			# proximo endereco %
00000389 : 0800037a;   % 1469: 			j 	loopfracreadFloat		# volta ao loop		 %
0000038a : 44801000;   % 1473: potreadFloat:		mtc1 	$zero, $f2			# zera potencia %
0000038b : 22680001;   % 1474: 			addi 	$t0, $s3, 1			# endereco seguinte ao 'e' %
0000038c : 24140000;   % 1475: 			li 	$s4, 0				# sinal do expoente positivo %
0000038d : 81090000;   % 1476: 			lb 	$t1, 0($t0)			# le o caractere seguinte ao 'e' %
0000038e : 2001002d;   % 1477: 			beq	$t1, '-', potsinalnegreadFloat	# sinal do expoente esta escrito e eh positivo %
0000038f : 10290003;   % 1477:  %
00000390 : 2001002b;   % 1478: 			beq 	$t1, '+', potsinalposreadFloat	# sinal do expoente eh negativo %
00000391 : 10290002;   % 1478:  %
00000392 : 08000395;   % 1479: 			j 	pulapotsinalreadFloat		# nao esta escrito o sinal do expoente %
00000393 : 24140001;   % 1480: potsinalnegreadFloat:	li 	$s4, 1				# $s4=1 expoente negativo %
00000394 : 21080001;   % 1481: potsinalposreadFloat:	addi 	$t0, $t0, 1			# se tiver '-' ou '+' avanca para o proximo endereco %
00000395 : 0008a821;   % 1482: pulapotsinalreadFloat:	move 	$s5, $t0 			# Neste ponto $s5 contem o endereco do primeiro digito da pot e $s4 o sinal do expoente		 %
00000396 : 460008c6;   % 1484: 			mov.s 	$f3, $f1		# $f3 un/dez/cen = 1 %
00000397 : 240a0000;   % 1487: expreadFloat:		li 	$t2, 0			# zera expoente %
00000398 : 00104021;   % 1488: 			move 	$t0, $s0		# endereco do ultimo caractere da string %
00000399 : 240b000a;   % 1489: 			li 	$t3, 10			# numero dez %
0000039a : 240c0001;   % 1490: 			li 	$t4, 1			# und/dez/cent %
0000039b : 0115082a;   % 1492: loopexpreadFloat:	blt 	$t0, $s5, fimexpreadFloat	# ainda nao eh o endereco do primeiro digito? %
0000039c : 14200009;   % 1492:  %
0000039d : 81090000;   % 1493: 			lb 	$t1, 0($t0)			# le o caracter %
0000039e : 2129ffd0;   % 1494: 			addi 	$t1, $t1, -48			# converte ascii para decimal %
0000039f : 012c0018;   % 1495: 			mult 	$t1, $t4			# mul digito %
000003a0 : 00004812;   % 1496: 			mflo 	$t1 %
000003a1 : 01495020;   % 1497: 			add 	$t2, $t2, $t1			# soma ao exp %
000003a2 : 018b0018;   % 1498: 			mult 	$t4, $t3			# proxima casa decimal %
000003a3 : 00006012;   % 1499: 			mflo 	$t4 %
000003a4 : 2108ffff;   % 1500: 			add 	$t0, $t0, -1			# endereco anterior %
000003a5 : 0800039b;   % 1501: 			j loopexpreadFloat			# volta ao loop %
000003a6 : 46000886;   % 1505: 			mov.s 	$f2, $f1			# numero 10^exp  inicial=1 %
000003a7 : 460050c6;   % 1506: 			mov.s 	$f3, $f10			# se o sinal for + $f3 eh 10 %
000003a8 : 20010000;   % 1507: 			beq 	$s4, 0, sinalexpPosreadFloat	# se sinal exp positivo %
000003a9 : 10340001;   % 1507:  %
000003aa : 460a08c3;   % 1508: 			div.s 	$f3, $f1, $f10			# se o final for - $f3 eh 0.1 %
000003ab : 24080000;   % 1509: sinalexpPosreadFloat:	li 	$t0, 0				# contador  %
000003ac : 110a0003;   % 1510: sinalexpreadFloat: 	beq 	$t0, $t2, fimsinalexpreadFloat	# se chegou ao fim %
000003ad : 46031082;   % 1511: 			mul.s 	$f2, $f2, $f3			# multiplica pelo fator 10 ou 0.1 %
000003ae : 21080001;   % 1512: 			addi 	$t0, $t0, 1			# incrementa o contador %
000003af : 080003ac;   % 1513: 			j 	sinalexpreadFloat %
000003b0 : 46020002;   % 1516: 		mul.s 	$f0, $f0, $f2		# multiplicacao final! %
000003b1 : 3c019000;   % 1518: 		la 	$t0, TempBuffer		# ajuste final do sinal do numero %
000003b2 : 3428044c;   % 1518:  %
000003b3 : 81090000;   % 1519: 		lb 	$t1, 0($t0)		# le primeiro caractere %
000003b4 : 2001002d;   % 1520: 		bne 	$t1, '-', fimreadFloat	# nao eh '-' entao fim %
000003b5 : 14290001;   % 1520:  %
000003b6 : 46000007;   % 1521: 		neg.s 	$f0, $f0		# nega o numero float %
000003b7 : 8fbf0000;   % 1524: fimreadFloat: 	lw 	$ra, 0($sp)		# recupera $ra %
000003b8 : 23bd0004;   % 1525: 		addi 	$sp, $sp, 4		# libera espaco %
000003b9 : 03e00008;   % 1526: 		jr 	$ra			# retorna %
000003ba : 3c011000;   % 1618: <57> bne $gp,0x10008000,timeDE2 %
000003bb : 34218000;   % 1618:  %
000003bc : 143c0003;   % 1618:  %
000003bd : 2402001e;   % 1619: 	li 	$v0,30				# Chama o syscall do Mars %
000003be : 0000000c;   % 1620: 	syscall %
000003bf : 080003c4;   % 1621: 	j 	fimTime				# saida %
000003c0 : 3c01ff20;   % 1623: timeDE2: 	la 	$t0, 0xFF200510			# carrega endereco do TopWatch %
000003c1 : 34280510;   % 1623:  %
000003c2 : 8d040000;   % 1624: 	 	lw 	$a0, 0($t0)			# carrega o valor do contador de ms %
000003c3 : 24050000;   % 1625: 	 	li 	$a1, 0x0000			# contador eh de 32 bits %
000003c4 : 03e00008;   % 1626: fimTime: 	jr 	$ra				# retorna %
000003c5 : 3c011000;   % 1632: <57> bne $gp,0x10008000,sleepDE2 %
000003c6 : 34218000;   % 1632:  %
000003c7 : 143c0003;   % 1632:  %
000003c8 : 24020020;   % 1633: 	li 	$v0, 32				# Chama o syscall do Mars %
000003c9 : 0000000c;   % 1634: 	syscall			 %
000003ca : 080003d2;   % 1635: 	j 	fimSleep			# Saida %
000003cb : 3c01ff20;   % 1637: sleepDE2:	la 	$t0, 0xFF200510			# endereco StopWatch %
000003cc : 34280510;   % 1637:  %
000003cd : 8d090000;   % 1638: 		lw 	$t1, 0($t0)			# carrega o contador de ms %
000003ce : 00895020;   % 1639: 		add 	$t2, $a0, $t1			# soma com o tempo solicitado pelo usuario %
000003cf : 8d090000;   % 1641: LoopSleep: 	lw 	$t1, 0($t0)			# carrega o contador de ms %
000003d0 : 012a082a;   % 1642: 		blt 	$t1, $t2, LoopSleep		# nao chegou ao fim volta ao loop %
000003d1 : 1420fffd;   % 1642:  %
000003d2 : 03e00008;   % 1644: fimSleep: 	jr 	$ra				# retorna %
000003d3 : 3c011000;   % 1650: <57> bne $gp,0x10008000,randomDE2 %
000003d4 : 34218000;   % 1650:  %
000003d5 : 143c0003;   % 1650:  %
000003d6 : 24020029;   % 1651: 	li 	$v0,41			# Chama o syscall do Mars %
000003d7 : 0000000c;   % 1652: 	syscall	 %
000003d8 : 080003dc;   % 1653: 	j 	fimRandom		# saida %
000003d9 : 3c01ff20;   % 1655: randomDE2: 	la 	$t0, 0xFF200514		# carrega endereco do LFSR %
000003da : 34280514;   % 1655:  %
000003db : 8d040000;   % 1656: 		lw 	$a0, 0($t0)		# le a word em $a0 %
000003dc : 03e00008;   % 1658: fimRandom:	jr 	$ra			# retorna %
000003dd : 3c01ff00;   % 1667: clsCLS:	la      $t1, 0xFF000000           # Memoria VGA %
000003de : 34290000;   % 1667:  %
000003df : 3c01ff01;   % 1668:    	la      $t2, 0xFF012C00 %
000003e0 : 342a2c00;   % 1668:  %
000003e1 : 308400ff;   % 1669:     	andi    $a0, $a0, 0x00FF %
000003e2 : 3c010101;   % 1670:     	la 	$t0, 0x01010101 %
000003e3 : 34280101;   % 1670:  %
000003e4 : 01040018;   % 1671:     	mult	$t0, $a0 %
000003e5 : 00002012;   % 1672:     	mflo	$a0 %
000003e6 : 112a0003;   % 1674: forCLS:	beq     $t1, $t2, fimCLS %
000003e7 : ad240000;   % 1675: 	sw      $a0, 0($t1) %
000003e8 : 21290004;   % 1676:     	addi    $t1, $t1, 4 %
000003e9 : 080003e6;   % 1677:     	j       forCLS %
000003ea : 03e00008;   % 1679: fimCLS:	jr      $ra %
END;
